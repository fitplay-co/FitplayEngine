// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ACTIONDATA_ACTIONDATA_H_
#define FLATBUFFERS_GENERATED_ACTIONDATA_ACTIONDATA_H_

#include "flatbuffers/flatbuffers.h"

namespace actionData {

struct General;
struct GeneralBuilder;

struct Stand;
struct StandBuilder;

struct Walk;
struct WalkBuilder;

struct Jump;
struct JumpBuilder;

struct Squat;
struct SquatBuilder;

struct Gaze;
struct GazeBuilder;

struct Ground;
struct GroundBuilder;

struct Joint;
struct JointBuilder;

struct FkLandmark;
struct FkLandmarkBuilder;

struct Fitting;
struct FittingBuilder;

struct Action;
struct ActionBuilder;

struct General FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeneralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIDENCE = 4
  };
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct GeneralBuilder {
  typedef General Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(General::VT_CONFIDENCE, confidence, 0.0f);
  }
  explicit GeneralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<General> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<General>(end);
    return o;
  }
};

inline flatbuffers::Offset<General> CreateGeneral(
    flatbuffers::FlatBufferBuilder &_fbb,
    float confidence = 0.0f) {
  GeneralBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  return builder_.Finish();
}

struct Stand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  float mode() const {
    return GetField<float>(VT_MODE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MODE, 4) &&
           verifier.EndTable();
  }
};

struct StandBuilder {
  typedef Stand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(float mode) {
    fbb_.AddElement<float>(Stand::VT_MODE, mode, 0.0f);
  }
  explicit StandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Stand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Stand>(end);
    return o;
  }
};

inline flatbuffers::Offset<Stand> CreateStand(
    flatbuffers::FlatBufferBuilder &_fbb,
    float mode = 0.0f) {
  StandBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct Walk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WalkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEFTLEG = 4,
    VT_RIGHTLEG = 6,
    VT_LEFTFREQUENCY = 8,
    VT_RIGHTFREQUENCY = 10,
    VT_LEFTHIPANG = 12,
    VT_RIGHTHIPANG = 14,
    VT_LEFTSTEPLENGTH = 16,
    VT_RIGHTSTEPLENGTH = 18,
    VT_LEFTPROGRESS = 20,
    VT_RIGHTPROGRESS = 22,
    VT_TURN = 24,
    VT_STEPRATE = 26,
    VT_STEPLEN = 28,
    VT_VELOCITY = 30,
    VT_VELOCITYTHRESHOLD = 32,
    VT_REALTIMELEFTLEG = 34,
    VT_REALTIMERIGHTLEG = 36
  };
  float leftLeg() const {
    return GetField<float>(VT_LEFTLEG, 0.0f);
  }
  float rightLeg() const {
    return GetField<float>(VT_RIGHTLEG, 0.0f);
  }
  float leftFrequency() const {
    return GetField<float>(VT_LEFTFREQUENCY, 0.0f);
  }
  float rightFrequency() const {
    return GetField<float>(VT_RIGHTFREQUENCY, 0.0f);
  }
  float leftHipAng() const {
    return GetField<float>(VT_LEFTHIPANG, 0.0f);
  }
  float rightHipAng() const {
    return GetField<float>(VT_RIGHTHIPANG, 0.0f);
  }
  float leftStepLength() const {
    return GetField<float>(VT_LEFTSTEPLENGTH, 0.0f);
  }
  float rightStepLength() const {
    return GetField<float>(VT_RIGHTSTEPLENGTH, 0.0f);
  }
  float leftProgress() const {
    return GetField<float>(VT_LEFTPROGRESS, 0.0f);
  }
  float rightProgress() const {
    return GetField<float>(VT_RIGHTPROGRESS, 0.0f);
  }
  float turn() const {
    return GetField<float>(VT_TURN, 0.0f);
  }
  float stepRate() const {
    return GetField<float>(VT_STEPRATE, 0.0f);
  }
  float stepLen() const {
    return GetField<float>(VT_STEPLEN, 0.0f);
  }
  float velocity() const {
    return GetField<float>(VT_VELOCITY, 0.0f);
  }
  float velocityThreshold() const {
    return GetField<float>(VT_VELOCITYTHRESHOLD, 0.0f);
  }
  float realtimeLeftLeg() const {
    return GetField<float>(VT_REALTIMELEFTLEG, 0.0f);
  }
  float realtimeRightLeg() const {
    return GetField<float>(VT_REALTIMERIGHTLEG, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LEFTLEG, 4) &&
           VerifyField<float>(verifier, VT_RIGHTLEG, 4) &&
           VerifyField<float>(verifier, VT_LEFTFREQUENCY, 4) &&
           VerifyField<float>(verifier, VT_RIGHTFREQUENCY, 4) &&
           VerifyField<float>(verifier, VT_LEFTHIPANG, 4) &&
           VerifyField<float>(verifier, VT_RIGHTHIPANG, 4) &&
           VerifyField<float>(verifier, VT_LEFTSTEPLENGTH, 4) &&
           VerifyField<float>(verifier, VT_RIGHTSTEPLENGTH, 4) &&
           VerifyField<float>(verifier, VT_LEFTPROGRESS, 4) &&
           VerifyField<float>(verifier, VT_RIGHTPROGRESS, 4) &&
           VerifyField<float>(verifier, VT_TURN, 4) &&
           VerifyField<float>(verifier, VT_STEPRATE, 4) &&
           VerifyField<float>(verifier, VT_STEPLEN, 4) &&
           VerifyField<float>(verifier, VT_VELOCITY, 4) &&
           VerifyField<float>(verifier, VT_VELOCITYTHRESHOLD, 4) &&
           VerifyField<float>(verifier, VT_REALTIMELEFTLEG, 4) &&
           VerifyField<float>(verifier, VT_REALTIMERIGHTLEG, 4) &&
           verifier.EndTable();
  }
};

struct WalkBuilder {
  typedef Walk Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_leftLeg(float leftLeg) {
    fbb_.AddElement<float>(Walk::VT_LEFTLEG, leftLeg, 0.0f);
  }
  void add_rightLeg(float rightLeg) {
    fbb_.AddElement<float>(Walk::VT_RIGHTLEG, rightLeg, 0.0f);
  }
  void add_leftFrequency(float leftFrequency) {
    fbb_.AddElement<float>(Walk::VT_LEFTFREQUENCY, leftFrequency, 0.0f);
  }
  void add_rightFrequency(float rightFrequency) {
    fbb_.AddElement<float>(Walk::VT_RIGHTFREQUENCY, rightFrequency, 0.0f);
  }
  void add_leftHipAng(float leftHipAng) {
    fbb_.AddElement<float>(Walk::VT_LEFTHIPANG, leftHipAng, 0.0f);
  }
  void add_rightHipAng(float rightHipAng) {
    fbb_.AddElement<float>(Walk::VT_RIGHTHIPANG, rightHipAng, 0.0f);
  }
  void add_leftStepLength(float leftStepLength) {
    fbb_.AddElement<float>(Walk::VT_LEFTSTEPLENGTH, leftStepLength, 0.0f);
  }
  void add_rightStepLength(float rightStepLength) {
    fbb_.AddElement<float>(Walk::VT_RIGHTSTEPLENGTH, rightStepLength, 0.0f);
  }
  void add_leftProgress(float leftProgress) {
    fbb_.AddElement<float>(Walk::VT_LEFTPROGRESS, leftProgress, 0.0f);
  }
  void add_rightProgress(float rightProgress) {
    fbb_.AddElement<float>(Walk::VT_RIGHTPROGRESS, rightProgress, 0.0f);
  }
  void add_turn(float turn) {
    fbb_.AddElement<float>(Walk::VT_TURN, turn, 0.0f);
  }
  void add_stepRate(float stepRate) {
    fbb_.AddElement<float>(Walk::VT_STEPRATE, stepRate, 0.0f);
  }
  void add_stepLen(float stepLen) {
    fbb_.AddElement<float>(Walk::VT_STEPLEN, stepLen, 0.0f);
  }
  void add_velocity(float velocity) {
    fbb_.AddElement<float>(Walk::VT_VELOCITY, velocity, 0.0f);
  }
  void add_velocityThreshold(float velocityThreshold) {
    fbb_.AddElement<float>(Walk::VT_VELOCITYTHRESHOLD, velocityThreshold, 0.0f);
  }
  void add_realtimeLeftLeg(float realtimeLeftLeg) {
    fbb_.AddElement<float>(Walk::VT_REALTIMELEFTLEG, realtimeLeftLeg, 0.0f);
  }
  void add_realtimeRightLeg(float realtimeRightLeg) {
    fbb_.AddElement<float>(Walk::VT_REALTIMERIGHTLEG, realtimeRightLeg, 0.0f);
  }
  explicit WalkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Walk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Walk>(end);
    return o;
  }
};

inline flatbuffers::Offset<Walk> CreateWalk(
    flatbuffers::FlatBufferBuilder &_fbb,
    float leftLeg = 0.0f,
    float rightLeg = 0.0f,
    float leftFrequency = 0.0f,
    float rightFrequency = 0.0f,
    float leftHipAng = 0.0f,
    float rightHipAng = 0.0f,
    float leftStepLength = 0.0f,
    float rightStepLength = 0.0f,
    float leftProgress = 0.0f,
    float rightProgress = 0.0f,
    float turn = 0.0f,
    float stepRate = 0.0f,
    float stepLen = 0.0f,
    float velocity = 0.0f,
    float velocityThreshold = 0.0f,
    float realtimeLeftLeg = 0.0f,
    float realtimeRightLeg = 0.0f) {
  WalkBuilder builder_(_fbb);
  builder_.add_realtimeRightLeg(realtimeRightLeg);
  builder_.add_realtimeLeftLeg(realtimeLeftLeg);
  builder_.add_velocityThreshold(velocityThreshold);
  builder_.add_velocity(velocity);
  builder_.add_stepLen(stepLen);
  builder_.add_stepRate(stepRate);
  builder_.add_turn(turn);
  builder_.add_rightProgress(rightProgress);
  builder_.add_leftProgress(leftProgress);
  builder_.add_rightStepLength(rightStepLength);
  builder_.add_leftStepLength(leftStepLength);
  builder_.add_rightHipAng(rightHipAng);
  builder_.add_leftHipAng(leftHipAng);
  builder_.add_rightFrequency(rightFrequency);
  builder_.add_leftFrequency(leftFrequency);
  builder_.add_rightLeg(rightLeg);
  builder_.add_leftLeg(leftLeg);
  return builder_.Finish();
}

struct Jump FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JumpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ONTHEGROUND = 4,
    VT_VELOCITY = 6
  };
  float onTheGround() const {
    return GetField<float>(VT_ONTHEGROUND, 0.0f);
  }
  float velocity() const {
    return GetField<float>(VT_VELOCITY, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ONTHEGROUND, 4) &&
           VerifyField<float>(verifier, VT_VELOCITY, 4) &&
           verifier.EndTable();
  }
};

struct JumpBuilder {
  typedef Jump Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_onTheGround(float onTheGround) {
    fbb_.AddElement<float>(Jump::VT_ONTHEGROUND, onTheGround, 0.0f);
  }
  void add_velocity(float velocity) {
    fbb_.AddElement<float>(Jump::VT_VELOCITY, velocity, 0.0f);
  }
  explicit JumpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Jump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Jump>(end);
    return o;
  }
};

inline flatbuffers::Offset<Jump> CreateJump(
    flatbuffers::FlatBufferBuilder &_fbb,
    float onTheGround = 0.0f,
    float velocity = 0.0f) {
  JumpBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  builder_.add_onTheGround(onTheGround);
  return builder_.Finish();
}

struct Squat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4
  };
  float status() const {
    return GetField<float>(VT_STATUS, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_STATUS, 4) &&
           verifier.EndTable();
  }
};

struct SquatBuilder {
  typedef Squat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(float status) {
    fbb_.AddElement<float>(Squat::VT_STATUS, status, 0.0f);
  }
  explicit SquatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Squat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Squat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Squat> CreateSquat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float status = 0.0f) {
  SquatBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

struct Gaze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GazeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           verifier.EndTable();
  }
};

struct GazeBuilder {
  typedef Gaze Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Gaze::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Gaze::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Gaze::VT_Z, z, 0.0f);
  }
  explicit GazeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Gaze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gaze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gaze> CreateGaze(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  GazeBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Ground FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GroundBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8,
    VT_LEGLENGTH = 10,
    VT_TRACING = 12,
    VT_DEBUGINFO = 14
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  float legLength() const {
    return GetField<float>(VT_LEGLENGTH, 0.0f);
  }
  float tracing() const {
    return GetField<float>(VT_TRACING, 0.0f);
  }
  const flatbuffers::String *debugInfo() const {
    return GetPointer<const flatbuffers::String *>(VT_DEBUGINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           VerifyField<float>(verifier, VT_LEGLENGTH, 4) &&
           VerifyField<float>(verifier, VT_TRACING, 4) &&
           VerifyOffset(verifier, VT_DEBUGINFO) &&
           verifier.VerifyString(debugInfo()) &&
           verifier.EndTable();
  }
};

struct GroundBuilder {
  typedef Ground Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Ground::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Ground::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Ground::VT_Z, z, 0.0f);
  }
  void add_legLength(float legLength) {
    fbb_.AddElement<float>(Ground::VT_LEGLENGTH, legLength, 0.0f);
  }
  void add_tracing(float tracing) {
    fbb_.AddElement<float>(Ground::VT_TRACING, tracing, 0.0f);
  }
  void add_debugInfo(flatbuffers::Offset<flatbuffers::String> debugInfo) {
    fbb_.AddOffset(Ground::VT_DEBUGINFO, debugInfo);
  }
  explicit GroundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Ground> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ground>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ground> CreateGround(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    float legLength = 0.0f,
    float tracing = 0.0f,
    flatbuffers::Offset<flatbuffers::String> debugInfo = 0) {
  GroundBuilder builder_(_fbb);
  builder_.add_debugInfo(debugInfo);
  builder_.add_tracing(tracing);
  builder_.add_legLength(legLength);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

inline flatbuffers::Offset<Ground> CreateGroundDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    float legLength = 0.0f,
    float tracing = 0.0f,
    const char *debugInfo = nullptr) {
  auto debugInfo__ = debugInfo ? _fbb.CreateString(debugInfo) : 0;
  return actionData::CreateGround(
      _fbb,
      x,
      y,
      z,
      legLength,
      tracing,
      debugInfo__);
}

struct Joint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_W = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_NAME = 12
  };
  float w() const {
    return GetField<float>(VT_W, 0.0f);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_W, 4) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct JointBuilder {
  typedef Joint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_w(float w) {
    fbb_.AddElement<float>(Joint::VT_W, w, 0.0f);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(Joint::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Joint::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Joint::VT_Z, z, 0.0f);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Joint::VT_NAME, name);
  }
  explicit JointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Joint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Joint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Joint> CreateJoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    float w = 0.0f,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  JointBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_w(w);
  return builder_.Finish();
}

inline flatbuffers::Offset<Joint> CreateJointDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float w = 0.0f,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return actionData::CreateJoint(
      _fbb,
      w,
      x,
      y,
      z,
      name__);
}

struct FkLandmark FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FkLandmarkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8,
    VT_NAME = 10
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct FkLandmarkBuilder {
  typedef FkLandmark Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(FkLandmark::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(FkLandmark::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(FkLandmark::VT_Z, z, 0.0f);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FkLandmark::VT_NAME, name);
  }
  explicit FkLandmarkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FkLandmark> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FkLandmark>(end);
    return o;
  }
};

inline flatbuffers::Offset<FkLandmark> CreateFkLandmark(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  FkLandmarkBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

inline flatbuffers::Offset<FkLandmark> CreateFkLandmarkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return actionData::CreateFkLandmark(
      _fbb,
      x,
      y,
      z,
      name__);
}

struct Fitting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FittingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROTATION = 4,
    VT_MIRRORROTATION = 6,
    VT_LOCALROTATION = 8,
    VT_MIRRORLOCALROTATION = 10,
    VT_FITTEDLANDMARKS = 12,
    VT_FITTEDERROR = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *rotation() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *>(VT_ROTATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *mirrorRotation() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *>(VT_MIRRORROTATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *localRotation() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *>(VT_LOCALROTATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *mirrorLocalRotation() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *>(VT_MIRRORLOCALROTATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<actionData::FkLandmark>> *fittedLandmarks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<actionData::FkLandmark>> *>(VT_FITTEDLANDMARKS);
  }
  float fittedError() const {
    return GetField<float>(VT_FITTEDERROR, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROTATION) &&
           verifier.VerifyVector(rotation()) &&
           verifier.VerifyVectorOfTables(rotation()) &&
           VerifyOffset(verifier, VT_MIRRORROTATION) &&
           verifier.VerifyVector(mirrorRotation()) &&
           verifier.VerifyVectorOfTables(mirrorRotation()) &&
           VerifyOffset(verifier, VT_LOCALROTATION) &&
           verifier.VerifyVector(localRotation()) &&
           verifier.VerifyVectorOfTables(localRotation()) &&
           VerifyOffset(verifier, VT_MIRRORLOCALROTATION) &&
           verifier.VerifyVector(mirrorLocalRotation()) &&
           verifier.VerifyVectorOfTables(mirrorLocalRotation()) &&
           VerifyOffset(verifier, VT_FITTEDLANDMARKS) &&
           verifier.VerifyVector(fittedLandmarks()) &&
           verifier.VerifyVectorOfTables(fittedLandmarks()) &&
           VerifyField<float>(verifier, VT_FITTEDERROR, 4) &&
           verifier.EndTable();
  }
};

struct FittingBuilder {
  typedef Fitting Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rotation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>>> rotation) {
    fbb_.AddOffset(Fitting::VT_ROTATION, rotation);
  }
  void add_mirrorRotation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>>> mirrorRotation) {
    fbb_.AddOffset(Fitting::VT_MIRRORROTATION, mirrorRotation);
  }
  void add_localRotation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>>> localRotation) {
    fbb_.AddOffset(Fitting::VT_LOCALROTATION, localRotation);
  }
  void add_mirrorLocalRotation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>>> mirrorLocalRotation) {
    fbb_.AddOffset(Fitting::VT_MIRRORLOCALROTATION, mirrorLocalRotation);
  }
  void add_fittedLandmarks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::FkLandmark>>> fittedLandmarks) {
    fbb_.AddOffset(Fitting::VT_FITTEDLANDMARKS, fittedLandmarks);
  }
  void add_fittedError(float fittedError) {
    fbb_.AddElement<float>(Fitting::VT_FITTEDERROR, fittedError, 0.0f);
  }
  explicit FittingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Fitting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fitting>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fitting> CreateFitting(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>>> rotation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>>> mirrorRotation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>>> localRotation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>>> mirrorLocalRotation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::FkLandmark>>> fittedLandmarks = 0,
    float fittedError = 0.0f) {
  FittingBuilder builder_(_fbb);
  builder_.add_fittedError(fittedError);
  builder_.add_fittedLandmarks(fittedLandmarks);
  builder_.add_mirrorLocalRotation(mirrorLocalRotation);
  builder_.add_localRotation(localRotation);
  builder_.add_mirrorRotation(mirrorRotation);
  builder_.add_rotation(rotation);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fitting> CreateFittingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<actionData::Joint>> *rotation = nullptr,
    const std::vector<flatbuffers::Offset<actionData::Joint>> *mirrorRotation = nullptr,
    const std::vector<flatbuffers::Offset<actionData::Joint>> *localRotation = nullptr,
    const std::vector<flatbuffers::Offset<actionData::Joint>> *mirrorLocalRotation = nullptr,
    const std::vector<flatbuffers::Offset<actionData::FkLandmark>> *fittedLandmarks = nullptr,
    float fittedError = 0.0f) {
  auto rotation__ = rotation ? _fbb.CreateVector<flatbuffers::Offset<actionData::Joint>>(*rotation) : 0;
  auto mirrorRotation__ = mirrorRotation ? _fbb.CreateVector<flatbuffers::Offset<actionData::Joint>>(*mirrorRotation) : 0;
  auto localRotation__ = localRotation ? _fbb.CreateVector<flatbuffers::Offset<actionData::Joint>>(*localRotation) : 0;
  auto mirrorLocalRotation__ = mirrorLocalRotation ? _fbb.CreateVector<flatbuffers::Offset<actionData::Joint>>(*mirrorLocalRotation) : 0;
  auto fittedLandmarks__ = fittedLandmarks ? _fbb.CreateVector<flatbuffers::Offset<actionData::FkLandmark>>(*fittedLandmarks) : 0;
  return actionData::CreateFitting(
      _fbb,
      rotation__,
      mirrorRotation__,
      localRotation__,
      mirrorLocalRotation__,
      fittedLandmarks__,
      fittedError);
}

struct Action FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GENERAL = 4,
    VT_STAND = 6,
    VT_WALK = 8,
    VT_JUMP = 10,
    VT_GAZE = 12,
    VT_SQUAT = 14,
    VT_GROUND = 16,
    VT_FITTING = 18
  };
  const actionData::General *general() const {
    return GetPointer<const actionData::General *>(VT_GENERAL);
  }
  const actionData::Stand *stand() const {
    return GetPointer<const actionData::Stand *>(VT_STAND);
  }
  const actionData::Walk *walk() const {
    return GetPointer<const actionData::Walk *>(VT_WALK);
  }
  const actionData::Jump *jump() const {
    return GetPointer<const actionData::Jump *>(VT_JUMP);
  }
  const actionData::Gaze *gaze() const {
    return GetPointer<const actionData::Gaze *>(VT_GAZE);
  }
  const actionData::Squat *squat() const {
    return GetPointer<const actionData::Squat *>(VT_SQUAT);
  }
  const actionData::Ground *ground() const {
    return GetPointer<const actionData::Ground *>(VT_GROUND);
  }
  const actionData::Fitting *fitting() const {
    return GetPointer<const actionData::Fitting *>(VT_FITTING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GENERAL) &&
           verifier.VerifyTable(general()) &&
           VerifyOffset(verifier, VT_STAND) &&
           verifier.VerifyTable(stand()) &&
           VerifyOffset(verifier, VT_WALK) &&
           verifier.VerifyTable(walk()) &&
           VerifyOffset(verifier, VT_JUMP) &&
           verifier.VerifyTable(jump()) &&
           VerifyOffset(verifier, VT_GAZE) &&
           verifier.VerifyTable(gaze()) &&
           VerifyOffset(verifier, VT_SQUAT) &&
           verifier.VerifyTable(squat()) &&
           VerifyOffset(verifier, VT_GROUND) &&
           verifier.VerifyTable(ground()) &&
           VerifyOffset(verifier, VT_FITTING) &&
           verifier.VerifyTable(fitting()) &&
           verifier.EndTable();
  }
};

struct ActionBuilder {
  typedef Action Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_general(flatbuffers::Offset<actionData::General> general) {
    fbb_.AddOffset(Action::VT_GENERAL, general);
  }
  void add_stand(flatbuffers::Offset<actionData::Stand> stand) {
    fbb_.AddOffset(Action::VT_STAND, stand);
  }
  void add_walk(flatbuffers::Offset<actionData::Walk> walk) {
    fbb_.AddOffset(Action::VT_WALK, walk);
  }
  void add_jump(flatbuffers::Offset<actionData::Jump> jump) {
    fbb_.AddOffset(Action::VT_JUMP, jump);
  }
  void add_gaze(flatbuffers::Offset<actionData::Gaze> gaze) {
    fbb_.AddOffset(Action::VT_GAZE, gaze);
  }
  void add_squat(flatbuffers::Offset<actionData::Squat> squat) {
    fbb_.AddOffset(Action::VT_SQUAT, squat);
  }
  void add_ground(flatbuffers::Offset<actionData::Ground> ground) {
    fbb_.AddOffset(Action::VT_GROUND, ground);
  }
  void add_fitting(flatbuffers::Offset<actionData::Fitting> fitting) {
    fbb_.AddOffset(Action::VT_FITTING, fitting);
  }
  explicit ActionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Action> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Action>(end);
    return o;
  }
};

inline flatbuffers::Offset<Action> CreateAction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<actionData::General> general = 0,
    flatbuffers::Offset<actionData::Stand> stand = 0,
    flatbuffers::Offset<actionData::Walk> walk = 0,
    flatbuffers::Offset<actionData::Jump> jump = 0,
    flatbuffers::Offset<actionData::Gaze> gaze = 0,
    flatbuffers::Offset<actionData::Squat> squat = 0,
    flatbuffers::Offset<actionData::Ground> ground = 0,
    flatbuffers::Offset<actionData::Fitting> fitting = 0) {
  ActionBuilder builder_(_fbb);
  builder_.add_fitting(fitting);
  builder_.add_ground(ground);
  builder_.add_squat(squat);
  builder_.add_gaze(gaze);
  builder_.add_jump(jump);
  builder_.add_walk(walk);
  builder_.add_stand(stand);
  builder_.add_general(general);
  return builder_.Finish();
}

inline const actionData::Action *GetAction(const void *buf) {
  return flatbuffers::GetRoot<actionData::Action>(buf);
}

inline const actionData::Action *GetSizePrefixedAction(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<actionData::Action>(buf);
}

inline bool VerifyActionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<actionData::Action>(nullptr);
}

inline bool VerifySizePrefixedActionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<actionData::Action>(nullptr);
}

inline void FinishActionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<actionData::Action> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedActionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<actionData::Action> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace actionData

#endif  // FLATBUFFERS_GENERATED_ACTIONDATA_ACTIONDATA_H_
