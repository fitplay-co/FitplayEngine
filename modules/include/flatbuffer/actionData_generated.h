// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ACTIONDATA_ACTIONDATA_H_
#define FLATBUFFERS_GENERATED_ACTIONDATA_ACTIONDATA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace actionData {

struct Walk;
struct WalkBuilder;

struct Jump;
struct JumpBuilder;

struct Gaze;
struct GazeBuilder;

struct Action;
struct ActionBuilder;

struct Walk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WalkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEGUP = 4,
    VT_FREQUENCY = 6,
    VT_STRENGTH = 8
  };
  float legUp() const {
    return GetField<float>(VT_LEGUP, 0.0f);
  }
  bool mutate_legUp(float _legUp = 0.0f) {
    return SetField<float>(VT_LEGUP, _legUp, 0.0f);
  }
  float frequency() const {
    return GetField<float>(VT_FREQUENCY, 0.0f);
  }
  bool mutate_frequency(float _frequency = 0.0f) {
    return SetField<float>(VT_FREQUENCY, _frequency, 0.0f);
  }
  float strength() const {
    return GetField<float>(VT_STRENGTH, 0.0f);
  }
  bool mutate_strength(float _strength = 0.0f) {
    return SetField<float>(VT_STRENGTH, _strength, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LEGUP, 4) &&
           VerifyField<float>(verifier, VT_FREQUENCY, 4) &&
           VerifyField<float>(verifier, VT_STRENGTH, 4) &&
           verifier.EndTable();
  }
};

struct WalkBuilder {
  typedef Walk Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_legUp(float legUp) {
    fbb_.AddElement<float>(Walk::VT_LEGUP, legUp, 0.0f);
  }
  void add_frequency(float frequency) {
    fbb_.AddElement<float>(Walk::VT_FREQUENCY, frequency, 0.0f);
  }
  void add_strength(float strength) {
    fbb_.AddElement<float>(Walk::VT_STRENGTH, strength, 0.0f);
  }
  explicit WalkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Walk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Walk>(end);
    return o;
  }
};

inline flatbuffers::Offset<Walk> CreateWalk(
    flatbuffers::FlatBufferBuilder &_fbb,
    float legUp = 0.0f,
    float frequency = 0.0f,
    float strength = 0.0f) {
  WalkBuilder builder_(_fbb);
  builder_.add_strength(strength);
  builder_.add_frequency(frequency);
  builder_.add_legUp(legUp);
  return builder_.Finish();
}

struct Jump FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JumpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UP = 4,
    VT_STRENGTH = 6
  };
  float up() const {
    return GetField<float>(VT_UP, 0.0f);
  }
  bool mutate_up(float _up = 0.0f) {
    return SetField<float>(VT_UP, _up, 0.0f);
  }
  float strength() const {
    return GetField<float>(VT_STRENGTH, 0.0f);
  }
  bool mutate_strength(float _strength = 0.0f) {
    return SetField<float>(VT_STRENGTH, _strength, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_UP, 4) &&
           VerifyField<float>(verifier, VT_STRENGTH, 4) &&
           verifier.EndTable();
  }
};

struct JumpBuilder {
  typedef Jump Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_up(float up) {
    fbb_.AddElement<float>(Jump::VT_UP, up, 0.0f);
  }
  void add_strength(float strength) {
    fbb_.AddElement<float>(Jump::VT_STRENGTH, strength, 0.0f);
  }
  explicit JumpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Jump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Jump>(end);
    return o;
  }
};

inline flatbuffers::Offset<Jump> CreateJump(
    flatbuffers::FlatBufferBuilder &_fbb,
    float up = 0.0f,
    float strength = 0.0f) {
  JumpBuilder builder_(_fbb);
  builder_.add_strength(strength);
  builder_.add_up(up);
  return builder_.Finish();
}

struct Gaze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GazeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  bool mutate_x(float _x = 0.0f) {
    return SetField<float>(VT_X, _x, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  bool mutate_y(float _y = 0.0f) {
    return SetField<float>(VT_Y, _y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool mutate_z(float _z = 0.0f) {
    return SetField<float>(VT_Z, _z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           verifier.EndTable();
  }
};

struct GazeBuilder {
  typedef Gaze Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Gaze::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Gaze::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Gaze::VT_Z, z, 0.0f);
  }
  explicit GazeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Gaze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gaze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gaze> CreateGaze(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  GazeBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Action FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WALK = 4,
    VT_JUMP = 6,
    VT_GAZE = 8
  };
  const actionData::Walk *walk() const {
    return GetPointer<const actionData::Walk *>(VT_WALK);
  }
  actionData::Walk *mutable_walk() {
    return GetPointer<actionData::Walk *>(VT_WALK);
  }
  const actionData::Jump *jump() const {
    return GetPointer<const actionData::Jump *>(VT_JUMP);
  }
  actionData::Jump *mutable_jump() {
    return GetPointer<actionData::Jump *>(VT_JUMP);
  }
  const actionData::Gaze *gaze() const {
    return GetPointer<const actionData::Gaze *>(VT_GAZE);
  }
  actionData::Gaze *mutable_gaze() {
    return GetPointer<actionData::Gaze *>(VT_GAZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WALK) &&
           verifier.VerifyTable(walk()) &&
           VerifyOffset(verifier, VT_JUMP) &&
           verifier.VerifyTable(jump()) &&
           VerifyOffset(verifier, VT_GAZE) &&
           verifier.VerifyTable(gaze()) &&
           verifier.EndTable();
  }
};

struct ActionBuilder {
  typedef Action Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_walk(flatbuffers::Offset<actionData::Walk> walk) {
    fbb_.AddOffset(Action::VT_WALK, walk);
  }
  void add_jump(flatbuffers::Offset<actionData::Jump> jump) {
    fbb_.AddOffset(Action::VT_JUMP, jump);
  }
  void add_gaze(flatbuffers::Offset<actionData::Gaze> gaze) {
    fbb_.AddOffset(Action::VT_GAZE, gaze);
  }
  explicit ActionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Action> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Action>(end);
    return o;
  }
};

inline flatbuffers::Offset<Action> CreateAction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<actionData::Walk> walk = 0,
    flatbuffers::Offset<actionData::Jump> jump = 0,
    flatbuffers::Offset<actionData::Gaze> gaze = 0) {
  ActionBuilder builder_(_fbb);
  builder_.add_gaze(gaze);
  builder_.add_jump(jump);
  builder_.add_walk(walk);
  return builder_.Finish();
}

inline const actionData::Action *GetAction(const void *buf) {
  return flatbuffers::GetRoot<actionData::Action>(buf);
}

inline const actionData::Action *GetSizePrefixedAction(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<actionData::Action>(buf);
}

inline Action *GetMutableAction(void *buf) {
  return flatbuffers::GetMutableRoot<Action>(buf);
}

inline actionData::Action *GetMutableSizePrefixedAction(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<actionData::Action>(buf);
}

inline bool VerifyActionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<actionData::Action>(nullptr);
}

inline bool VerifySizePrefixedActionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<actionData::Action>(nullptr);
}

inline void FinishActionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<actionData::Action> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedActionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<actionData::Action> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace actionData

#endif  // FLATBUFFERS_GENERATED_ACTIONDATA_ACTIONDATA_H_
