// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ACTIONDATA_ACTIONDATA_H_
#define FLATBUFFERS_GENERATED_ACTIONDATA_ACTIONDATA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace actionData {

struct Walk;
struct WalkBuilder;

struct Jump;
struct JumpBuilder;

struct Squat;
struct SquatBuilder;

struct Gaze;
struct GazeBuilder;

struct Ground;
struct GroundBuilder;

struct Joint;
struct JointBuilder;

struct Fitting;
struct FittingBuilder;

struct Action;
struct ActionBuilder;

struct Walk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WalkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEGUP = 4,
    VT_FREQUENCY = 6,
    VT_STRENGTH = 8
  };
  float legUp() const {
    return GetField<float>(VT_LEGUP, 0.0f);
  }
  bool mutate_legUp(float _legUp = 0.0f) {
    return SetField<float>(VT_LEGUP, _legUp, 0.0f);
  }
  float frequency() const {
    return GetField<float>(VT_FREQUENCY, 0.0f);
  }
  bool mutate_frequency(float _frequency = 0.0f) {
    return SetField<float>(VT_FREQUENCY, _frequency, 0.0f);
  }
  float strength() const {
    return GetField<float>(VT_STRENGTH, 0.0f);
  }
  bool mutate_strength(float _strength = 0.0f) {
    return SetField<float>(VT_STRENGTH, _strength, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LEGUP, 4) &&
           VerifyField<float>(verifier, VT_FREQUENCY, 4) &&
           VerifyField<float>(verifier, VT_STRENGTH, 4) &&
           verifier.EndTable();
  }
};

struct WalkBuilder {
  typedef Walk Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_legUp(float legUp) {
    fbb_.AddElement<float>(Walk::VT_LEGUP, legUp, 0.0f);
  }
  void add_frequency(float frequency) {
    fbb_.AddElement<float>(Walk::VT_FREQUENCY, frequency, 0.0f);
  }
  void add_strength(float strength) {
    fbb_.AddElement<float>(Walk::VT_STRENGTH, strength, 0.0f);
  }
  explicit WalkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Walk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Walk>(end);
    return o;
  }
};

inline flatbuffers::Offset<Walk> CreateWalk(
    flatbuffers::FlatBufferBuilder &_fbb,
    float legUp = 0.0f,
    float frequency = 0.0f,
    float strength = 0.0f) {
  WalkBuilder builder_(_fbb);
  builder_.add_strength(strength);
  builder_.add_frequency(frequency);
  builder_.add_legUp(legUp);
  return builder_.Finish();
}

struct Jump FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JumpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UP = 4,
    VT_STRENGTH = 6
  };
  float up() const {
    return GetField<float>(VT_UP, 0.0f);
  }
  bool mutate_up(float _up = 0.0f) {
    return SetField<float>(VT_UP, _up, 0.0f);
  }
  float strength() const {
    return GetField<float>(VT_STRENGTH, 0.0f);
  }
  bool mutate_strength(float _strength = 0.0f) {
    return SetField<float>(VT_STRENGTH, _strength, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_UP, 4) &&
           VerifyField<float>(verifier, VT_STRENGTH, 4) &&
           verifier.EndTable();
  }
};

struct JumpBuilder {
  typedef Jump Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_up(float up) {
    fbb_.AddElement<float>(Jump::VT_UP, up, 0.0f);
  }
  void add_strength(float strength) {
    fbb_.AddElement<float>(Jump::VT_STRENGTH, strength, 0.0f);
  }
  explicit JumpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Jump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Jump>(end);
    return o;
  }
};

inline flatbuffers::Offset<Jump> CreateJump(
    flatbuffers::FlatBufferBuilder &_fbb,
    float up = 0.0f,
    float strength = 0.0f) {
  JumpBuilder builder_(_fbb);
  builder_.add_strength(strength);
  builder_.add_up(up);
  return builder_.Finish();
}

struct Squat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4
  };
  float status() const {
    return GetField<float>(VT_STATUS, 0.0f);
  }
  bool mutate_status(float _status = 0.0f) {
    return SetField<float>(VT_STATUS, _status, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_STATUS, 4) &&
           verifier.EndTable();
  }
};

struct SquatBuilder {
  typedef Squat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(float status) {
    fbb_.AddElement<float>(Squat::VT_STATUS, status, 0.0f);
  }
  explicit SquatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Squat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Squat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Squat> CreateSquat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float status = 0.0f) {
  SquatBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

struct Gaze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GazeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  bool mutate_x(float _x = 0.0f) {
    return SetField<float>(VT_X, _x, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  bool mutate_y(float _y = 0.0f) {
    return SetField<float>(VT_Y, _y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool mutate_z(float _z = 0.0f) {
    return SetField<float>(VT_Z, _z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           verifier.EndTable();
  }
};

struct GazeBuilder {
  typedef Gaze Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Gaze::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Gaze::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Gaze::VT_Z, z, 0.0f);
  }
  explicit GazeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Gaze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gaze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gaze> CreateGaze(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  GazeBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Ground FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GroundBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8,
    VT_LEGLENGTH = 10,
    VT_TRACING = 12
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  bool mutate_x(float _x = 0.0f) {
    return SetField<float>(VT_X, _x, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  bool mutate_y(float _y = 0.0f) {
    return SetField<float>(VT_Y, _y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool mutate_z(float _z = 0.0f) {
    return SetField<float>(VT_Z, _z, 0.0f);
  }
  float legLength() const {
    return GetField<float>(VT_LEGLENGTH, 0.0f);
  }
  bool mutate_legLength(float _legLength = 0.0f) {
    return SetField<float>(VT_LEGLENGTH, _legLength, 0.0f);
  }
  float tracing() const {
    return GetField<float>(VT_TRACING, 0.0f);
  }
  bool mutate_tracing(float _tracing = 0.0f) {
    return SetField<float>(VT_TRACING, _tracing, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           VerifyField<float>(verifier, VT_LEGLENGTH, 4) &&
           VerifyField<float>(verifier, VT_TRACING, 4) &&
           verifier.EndTable();
  }
};

struct GroundBuilder {
  typedef Ground Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Ground::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Ground::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Ground::VT_Z, z, 0.0f);
  }
  void add_legLength(float legLength) {
    fbb_.AddElement<float>(Ground::VT_LEGLENGTH, legLength, 0.0f);
  }
  void add_tracing(float tracing) {
    fbb_.AddElement<float>(Ground::VT_TRACING, tracing, 0.0f);
  }
  explicit GroundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Ground> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ground>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ground> CreateGround(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    float legLength = 0.0f,
    float tracing = 0.0f) {
  GroundBuilder builder_(_fbb);
  builder_.add_tracing(tracing);
  builder_.add_legLength(legLength);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Joint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_W = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_NAME = 12
  };
  float w() const {
    return GetField<float>(VT_W, 0.0f);
  }
  bool mutate_w(float _w = 0.0f) {
    return SetField<float>(VT_W, _w, 0.0f);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  bool mutate_x(float _x = 0.0f) {
    return SetField<float>(VT_X, _x, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  bool mutate_y(float _y = 0.0f) {
    return SetField<float>(VT_Y, _y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool mutate_z(float _z = 0.0f) {
    return SetField<float>(VT_Z, _z, 0.0f);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_W, 4) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct JointBuilder {
  typedef Joint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_w(float w) {
    fbb_.AddElement<float>(Joint::VT_W, w, 0.0f);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(Joint::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Joint::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Joint::VT_Z, z, 0.0f);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Joint::VT_NAME, name);
  }
  explicit JointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Joint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Joint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Joint> CreateJoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    float w = 0.0f,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  JointBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_w(w);
  return builder_.Finish();
}

inline flatbuffers::Offset<Joint> CreateJointDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float w = 0.0f,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return actionData::CreateJoint(
      _fbb,
      w,
      x,
      y,
      z,
      name__);
}

struct Fitting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FittingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROTATION = 4,
    VT_MIRRORROTATION = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *rotation() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *>(VT_ROTATION);
  }
  flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *mutable_rotation() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *>(VT_ROTATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *mirrorRotation() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *>(VT_MIRRORROTATION);
  }
  flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *mutable_mirrorRotation() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>> *>(VT_MIRRORROTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROTATION) &&
           verifier.VerifyVector(rotation()) &&
           verifier.VerifyVectorOfTables(rotation()) &&
           VerifyOffset(verifier, VT_MIRRORROTATION) &&
           verifier.VerifyVector(mirrorRotation()) &&
           verifier.VerifyVectorOfTables(mirrorRotation()) &&
           verifier.EndTable();
  }
};

struct FittingBuilder {
  typedef Fitting Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rotation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>>> rotation) {
    fbb_.AddOffset(Fitting::VT_ROTATION, rotation);
  }
  void add_mirrorRotation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>>> mirrorRotation) {
    fbb_.AddOffset(Fitting::VT_MIRRORROTATION, mirrorRotation);
  }
  explicit FittingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Fitting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fitting>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fitting> CreateFitting(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>>> rotation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<actionData::Joint>>> mirrorRotation = 0) {
  FittingBuilder builder_(_fbb);
  builder_.add_mirrorRotation(mirrorRotation);
  builder_.add_rotation(rotation);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fitting> CreateFittingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<actionData::Joint>> *rotation = nullptr,
    const std::vector<flatbuffers::Offset<actionData::Joint>> *mirrorRotation = nullptr) {
  auto rotation__ = rotation ? _fbb.CreateVector<flatbuffers::Offset<actionData::Joint>>(*rotation) : 0;
  auto mirrorRotation__ = mirrorRotation ? _fbb.CreateVector<flatbuffers::Offset<actionData::Joint>>(*mirrorRotation) : 0;
  return actionData::CreateFitting(
      _fbb,
      rotation__,
      mirrorRotation__);
}

struct Action FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WALK = 4,
    VT_JUMP = 6,
    VT_GAZE = 8,
    VT_SQUAT = 10,
    VT_GROUND = 12,
    VT_FITTING = 14
  };
  const actionData::Walk *walk() const {
    return GetPointer<const actionData::Walk *>(VT_WALK);
  }
  actionData::Walk *mutable_walk() {
    return GetPointer<actionData::Walk *>(VT_WALK);
  }
  const actionData::Jump *jump() const {
    return GetPointer<const actionData::Jump *>(VT_JUMP);
  }
  actionData::Jump *mutable_jump() {
    return GetPointer<actionData::Jump *>(VT_JUMP);
  }
  const actionData::Gaze *gaze() const {
    return GetPointer<const actionData::Gaze *>(VT_GAZE);
  }
  actionData::Gaze *mutable_gaze() {
    return GetPointer<actionData::Gaze *>(VT_GAZE);
  }
  const actionData::Squat *squat() const {
    return GetPointer<const actionData::Squat *>(VT_SQUAT);
  }
  actionData::Squat *mutable_squat() {
    return GetPointer<actionData::Squat *>(VT_SQUAT);
  }
  const actionData::Ground *ground() const {
    return GetPointer<const actionData::Ground *>(VT_GROUND);
  }
  actionData::Ground *mutable_ground() {
    return GetPointer<actionData::Ground *>(VT_GROUND);
  }
  const actionData::Fitting *fitting() const {
    return GetPointer<const actionData::Fitting *>(VT_FITTING);
  }
  actionData::Fitting *mutable_fitting() {
    return GetPointer<actionData::Fitting *>(VT_FITTING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WALK) &&
           verifier.VerifyTable(walk()) &&
           VerifyOffset(verifier, VT_JUMP) &&
           verifier.VerifyTable(jump()) &&
           VerifyOffset(verifier, VT_GAZE) &&
           verifier.VerifyTable(gaze()) &&
           VerifyOffset(verifier, VT_SQUAT) &&
           verifier.VerifyTable(squat()) &&
           VerifyOffset(verifier, VT_GROUND) &&
           verifier.VerifyTable(ground()) &&
           VerifyOffset(verifier, VT_FITTING) &&
           verifier.VerifyTable(fitting()) &&
           verifier.EndTable();
  }
};

struct ActionBuilder {
  typedef Action Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_walk(flatbuffers::Offset<actionData::Walk> walk) {
    fbb_.AddOffset(Action::VT_WALK, walk);
  }
  void add_jump(flatbuffers::Offset<actionData::Jump> jump) {
    fbb_.AddOffset(Action::VT_JUMP, jump);
  }
  void add_gaze(flatbuffers::Offset<actionData::Gaze> gaze) {
    fbb_.AddOffset(Action::VT_GAZE, gaze);
  }
  void add_squat(flatbuffers::Offset<actionData::Squat> squat) {
    fbb_.AddOffset(Action::VT_SQUAT, squat);
  }
  void add_ground(flatbuffers::Offset<actionData::Ground> ground) {
    fbb_.AddOffset(Action::VT_GROUND, ground);
  }
  void add_fitting(flatbuffers::Offset<actionData::Fitting> fitting) {
    fbb_.AddOffset(Action::VT_FITTING, fitting);
  }
  explicit ActionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Action> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Action>(end);
    return o;
  }
};

inline flatbuffers::Offset<Action> CreateAction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<actionData::Walk> walk = 0,
    flatbuffers::Offset<actionData::Jump> jump = 0,
    flatbuffers::Offset<actionData::Gaze> gaze = 0,
    flatbuffers::Offset<actionData::Squat> squat = 0,
    flatbuffers::Offset<actionData::Ground> ground = 0,
    flatbuffers::Offset<actionData::Fitting> fitting = 0) {
  ActionBuilder builder_(_fbb);
  builder_.add_fitting(fitting);
  builder_.add_ground(ground);
  builder_.add_squat(squat);
  builder_.add_gaze(gaze);
  builder_.add_jump(jump);
  builder_.add_walk(walk);
  return builder_.Finish();
}

inline const actionData::Action *GetAction(const void *buf) {
  return flatbuffers::GetRoot<actionData::Action>(buf);
}

inline const actionData::Action *GetSizePrefixedAction(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<actionData::Action>(buf);
}

inline Action *GetMutableAction(void *buf) {
  return flatbuffers::GetMutableRoot<Action>(buf);
}

inline actionData::Action *GetMutableSizePrefixedAction(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<actionData::Action>(buf);
}

inline bool VerifyActionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<actionData::Action>(nullptr);
}

inline bool VerifySizePrefixedActionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<actionData::Action>(nullptr);
}

inline void FinishActionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<actionData::Action> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedActionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<actionData::Action> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace actionData

#endif  // FLATBUFFERS_GENERATED_ACTIONDATA_ACTIONDATA_H_
